Internal Expense Tracker (Expensify Replacement) – Technical Requirements

Project Summary

This project entails developing a web-only internal expense tracking tool to replace basic Expensify functionality for a small agency. The application will allow employees to submit expense reports and receipts through a web interface (or via designated email/Google Form) and enable managers to approve or reject expenses. All data will be stored in Google Sheets for simplicity, and basic notification workflows will inform stakeholders of new submissions and approval decisions. The tool is internal-only – accessible to agency staff via web browser – and focuses on tracking and approval of expenses (it will not handle reimbursements or payments). By leveraging Google Workspace (Gmail, Forms, Sheets) integration and simple web technologies, the solution aims to streamline expense submission and approval while avoiding the complexity of full-featured expense management systems.

Key Objectives:
	•	Replace manual email/spreadsheet expense processes with a unified web application.
	•	Integrate with Google services for data input (email or form) and storage (Sheets) to minimize new infrastructure.
	•	Implement a basic approval workflow (submit → approve/reject → notify) similar to Expensify’s core features.
	•	Keep the scope to tracking and status updates – actual reimbursement processing is out of scope (handled separately by finance).

Functional Requirements
	•	Expense Submission via Email: Allow employees to submit expenses by sending receipts to a designated company email (e.g. receipts@agency.com). The system will connect to the Gmail inbox, retrieve new expense emails, and parse key details. For example, Expensify allows users to forward receipts to receipts@expensify.com for automatic processing ￼ – similarly, our tool will monitor the inbox for incoming receipts. Employees should include essential info (date, amount, description) in the email body or subject. (Note: In MVP, the email parser will expect a consistent format or keywords in the email – e.g. “Amount: $123.45” – to extract data. Attachments (images/PDF of receipts) will be saved or referenced, but full OCR of receipt images is not in MVP scope.)
	•	Expense Submission via Google Form: Provide an alternative submission method through a Google Form (accessible only to employees). The form will collect structured data fields like date of expense, amount, category/reason, department, and an uploaded receipt image ￼. The form should require login (if needed for file upload) to ensure only staff submit entries, and it will automatically log responses to a connected Google Sheet. This ensures data consistency and easy validation (e.g. enforcing numeric format for amount, date picker for date). The form will also capture the submitter’s email address for notification purposes ￼.
	•	Data Storage (Google Sheets Schema): Use a Google Sheets spreadsheet as the system’s database for all expenses. Each expense submission becomes a new row in a sheet. If using the Google Form, the form responses are recorded with columns corresponding to each field (e.g. Date, Amount, Reason, etc.) ￼. Additional columns will be added to track approval workflow data, such as Approval Status and Approval Notes ￼. The Approval Status column will indicate if an expense is “Pending”, “Approved”, or “Rejected”, and Approval Notes can store an optional manager comment. To maintain data integrity, implement data validation on relevant columns – for example, restrict the Approval Status column to a dropdown of “Approved” or “Rejected” options ￼, and ensure numeric fields (Amount) and date fields are in correct format. The sheet may also include an “ID” or timestamp column as a unique identifier for each expense, and a flag (e.g. “Email Sent”) to indicate if notification for that entry has been dispatched.
	•	Expense Approval Workflow: The tool will support a basic approve/reject process for submitted expenses:
	•	An Approver interface (web page) will list all submitted expenses, with key details (employee, date, amount, reason, receipt link, etc.) and their current status. Approvers (e.g. managers or finance staff) can review each entry and take action.
	•	Approvers should be able to mark an expense as “Approved” or “Rejected”, and provide an optional note or reason for rejection. When an approver updates the status, the Google Sheet should be updated in real-time (via the Sheets API) to reflect the decision and note. The system should prevent double-approving; once a decision is made, that entry’s status is final (unless an admin resets it).
	•	Expense Status Updates: When an expense’s status is updated (from “Pending” to “Approved/Rejected”), the change should be logged. The system could maintain an audit trail (at minimum, recording the approver’s identity and timestamp of approval in the sheet or a log) – this can be as simple as additional columns for “Approved By” and “Decision Date” in the spreadsheet.
	•	Notifications and Alerts: Implement automated notifications to keep everyone informed:
	•	When a new expense is submitted, notify the designated approver(s). For example, send an email alert or a Slack message to a specific channel or user group indicating “New expense report submitted by X, Amount $Y, awaiting approval.” This ensures approvers know to log in to the tool to review. Slack integration can use an Incoming Webhook for simplicity – the app posts a JSON payload to a Slack webhook URL to deliver messages ￼. (Email notifications for new submissions could also be sent if Slack is not used.)
	•	When an expense is approved or rejected, notify the original submitter of the decision. The system will send an email to the employee’s address with the approval status and any notes. This can be done via the Gmail API’s send capability or via a simple SMTP service. (E.g., “Your expense for $123 on 2025-06-01 has been Approved – [optional note].”) The tool will ensure each report triggers only one notification upon processing – e.g. by using an “Email Sent” flag in the sheet to avoid duplicate alerts ￼ ￼. According to a similar Google Apps Script workflow, an email notification should be sent to the employee once the expense report is processed (approved/rejected) ￼. Slack notifications for decisions can also be sent (e.g. a DM or channel message like “Expense #123 by X was approved”). All notification content should be concise and include necessary reference info (expense ID, amount, status, and a link to view details if applicable).
	•	User Roles & Access Control: Since this is an internal tool, access should be restricted:
	•	Employees (Submitters): Can submit expenses (via email or form). They might not need to log into the tool’s UI if submission is external (email/form), but if a web UI is provided for submissions, they should only see their own entries (optional for MVP). In any case, they receive notifications about their reports.
	•	Approvers (Managers/Finance): Can log into the web interface to review and approve/reject expenses. They should see all pending requests (or those relevant to their department if filtering is implemented). Only approvers can change the status.
	•	Authentication: For MVP, a simple access control can be implemented. For example, protect the approval page with a basic login (username/password) or restrict by IP/VPN if on an intranet. A more robust approach is to use Google OAuth for login – since all users have Google accounts, the app could authenticate via Google Sign-In and only allow @agency.com domain accounts. This could be a future enhancement if not done in MVP. All sensitive credentials (API keys, webhook URLs) must be stored securely (e.g. Replit secrets or environment variables) and not exposed on the frontend.
	•	Data Integrity & Validation: The system should validate inputs to minimize errors:
	•	Ensure required fields (amount, date, reason, etc.) are provided. If using a Google Form, make those questions mandatory and use form validation for correct data types (numbers, dates).
	•	If using email input, the parsing logic should check for presence of an amount and date in the email. Any emails that cannot be confidently parsed should be flagged for manual review (perhaps logged in a “Pending Manual Entry” list).
	•	The Google Sheet’s schema and data validation (drop-down for status, etc.) will help enforce consistency (e.g., only allowed status values, and maybe data validation rules for ranges or text length as needed).
	•	Avoid duplicate entries: e.g., if the same email is processed twice or if a form is resubmitted, the app should detect duplicates (perhaps by checking for identical amount+date+user combos or a unique email ID) and not create duplicate records.
	•	User Interface & Usability: Provide a clean, simple web UI for interaction:
	•	A dashboard page for approvers listing all Pending expenses with their details. This page should allow filtering or sorting (e.g., by submission date or employee).
	•	Action buttons or links to Approve or Reject each expense, with a way to input an approval note. Possibly use a modal or a separate detail view when clicking an expense to see full details (including the receipt image if available) before approving.
	•	If feasible, display the receipt attachment image or link for the approver to verify (for instance, if receipts are images stored on Google Drive or as attachments, provide a URL or thumbnail in the UI).
	•	After an action, the entry should update in the UI (e.g., move from Pending to an Approved/Rejected list or disappear from pending list). Confirmation messages (toasts or alerts) should inform the approver that the action succeeded.
	•	A basic submissions page for employees (optional in MVP): if authentication is in place, an employee could view the status of their past submissions. This could simply read filtered data from the Google Sheet (where the user’s email matches the logged-in user) and show statuses.

(The functional requirements above ensure that the tool covers the end-to-end flow: submission → storage → approval → notification, with data validation and security appropriate for an internal application.)

Technical Architecture Overview

The system will follow a web application client-server architecture, integrated with Google and Slack services. Below is an overview of the components and data flow:
	•	Web Application (Server): The core of the tool will run as a web server (e.g., a Node.js Express app or Python Flask app) hosted on Replit. This server will handle HTTP routes for the web interface and background tasks for processing emails and form data.
	•	Email Processor: A module or service in the app will periodically connect to the Gmail API to fetch new emails from the dedicated expense inbox. It will parse email content and attachments to extract expense data. New submissions identified via email will be added into the Google Sheet via the Sheets API.
	•	Google Form Handler: If using the Google Form route, the form itself feeds data to Google Sheets directly. The web app may also use the Google Sheets API to detect new form submissions (new rows) if any server-side actions are needed upon submission (e.g., trigger a Slack notification to approvers when a new row appears). This could be done by polling the sheet or using Google’s Form API (or Apps Script webhook) to notify the app on each submit. (For simplicity, the MVP might rely on the form->sheet linkage and have the approver interface read directly from the sheet for new entries.)
	•	Approval Workflow Logic: The server provides endpoints or UI actions for approving/rejecting expenses. When an approver clicks “Approve” or “Reject” on an expense in the web UI, the server (backend) will:
	1.	Update the Google Sheet row for that expense (set the status, add the note, etc.).
	2.	Trigger notification logic to inform the submitter (and possibly others) of the decision.
	3.	(Optional) Log the action (who approved, timestamp) if not already captured.
	•	Notification Dispatcher: A component to send out notifications. This will use:
	•	Gmail API (or an email service) to send notification emails to employees.
	•	Slack Webhook calls to post messages to Slack (for new submissions or perhaps summary of approvals). The Slack integration is one-way (posting messages), which is straightforward via an HTTP POST as Slack incoming webhooks accept a JSON payload ￼.
	•	The server may also expose internal API endpoints (e.g., a POST endpoint that the email parser or form trigger can call when new data is ready), but these would not be public – they’re part of the internal workflow.
	•	Web Client (Frontend): A simple web interface accessible via browser. This could be a server-rendered HTML (templated by the backend) or a minimal single-page app. Given the simplicity, an server-side rendered approach is fine:
	•	The frontend will consist of pages such as Login (if needed), Pending Expenses List, Expense Detail/Review, etc. This can be implemented with standard HTML/CSS and some JavaScript for interactivity (e.g., using fetch/AJAX to perform approve/reject without full page reload).
	•	Since this is internal and the user count is small, we don’t need a complex front-end framework – simple Bootstrap or similar for styling is sufficient. The focus is on clarity: tables or lists of expenses, and buttons to act on them.
	•	The client communicates with the server over HTTP(S) – for example, clicking “Approve” could send a POST request to /expenses/{id}/approve which the server handles.
	•	External Integrations:
	•	Gmail – for receiving submission emails and sending out notification emails. The app will use Gmail API to fetch emails (likely with a restricted scope such as read-only or specific label). The Gmail API provides secure RESTful access to Gmail mailboxes ￼. We might create a rule in Gmail to label or forward relevant emails, but using the API allows querying by criteria (e.g., unread emails in inbox or with subject containing “Expense”).
	•	Google Sheets – as the database. The Google Sheets API will be used to read and write expense data in the spreadsheet ￼. For example, when a new email submission comes in, the app will append a new row to the sheet via the API. When an approver changes a status, the app will update the specific cell(s) in the sheet. The sheet acts as the single source of truth for expense records.
	•	Google Forms – for structured input (if used). The form itself writes to Google Sheets (no additional architecture needed for that). Optionally, the Google Forms API or an Apps Script trigger could be used to call the web app upon each new submission, but polling the sheet for new rows is a simpler approach in MVP. The form’s role is primarily an alternate UI for submission feeding into the same sheet.
	•	Slack – for notifications. As mentioned, the simplest integration is an Incoming Webhook URL configured in a Slack App for the workspace. The server, upon certain events (new expense or status change), will send an HTTP POST with a JSON payload to the Slack webhook URL to post messages in Slack ￼. No data is read from Slack; it’s a one-way notification. This keeps things simple and avoids needing a full Slack bot token.
	•	System Workflow: To illustrate the end-to-end flow:
	1.	Submission – An employee submits an expense either by (a) sending an email with receipt, or (b) filling out the Google Form.
	•	For (a), the Gmail API is periodically polled by the server (or pushed via webhook if configured) to find new emails. When found, the app parses the email content. It then calls Google Sheets API to append a new row to the spreadsheet with the details.
	•	For (b), the Google Form directly appends a row to the spreadsheet with the responses.
	•	In both cases, a Slack message/email can alert approvers: e.g., “New expense submitted by Jane Doe, $45.00 for Office Supplies.”
	2.	Storage – The Google Sheet now has a new entry (status default “Pending”). Each entry might include the submitter’s email, so we know who to notify later.
	3.	Approval – A manager opens the web app and views the Pending list (which the server populates by reading the Google Sheet data via the API). The manager reviews the info (and possibly opens the attached receipt image via link). They click Approve or Reject. The web app sends the update to Google Sheets (set status, add note, add approver name/date).
	4.	Notification – Upon updating, the server triggers notifications. It uses Gmail API to send an email to the employee: e.g., “Your expense has been approved.” ￼. It can also post a Slack message in a channel like #expenses: e.g., “Expense ID 123 approved by Manager.” (Notification content and channels are configurable.)
	5.	Post-processing – The record in Google Sheet now shows the final status. The employee will handle reimbursement outside the system (e.g., they or finance use the approved info to issue payment via payroll or petty cash). The tool does not perform any payment logic – it’s purely for record-keeping and approval tracking.
	•	Scheduling & Performance: Since the app relies on polling for new emails (and possibly new sheet entries), we should schedule these checks at a reasonable interval (e.g., every 5 or 10 minutes) to balance timeliness and API quotas. Replit doesn’t natively have a cron, but we can use a loop with delays or leverage external cron services or Replit’s Always-On feature. Google’s APIs have usage limits, but a small agency with infrequent submissions should be well within free tier quotas. The data volume is low (Google Sheets can handle thousands of rows easily), and real-time concurrency is minimal (only a few managers using the site at once), so a single server instance is sufficient.
	•	Error Handling & Monitoring: The architecture should include basic error handling:
	•	If an email fails to parse or a Sheets update fails, log the error (maybe to console or to a separate “Error Log” sheet) and alert an admin if needed.
	•	Gmail API errors (e.g., auth issues, rate limits) and Sheets API errors should be caught and logged. Since it’s internal, a simple approach is to display an error message on the web UI if something goes wrong, and have an admin interface to view logs or reprocess failed items.
	•	The system can also mark problematic entries (e.g., if an email was fetched but couldn’t be parsed into a proper expense record, it could send a notification to an admin or put a placeholder in the sheet for manual review).

In summary, the technical architecture consists of a Replit-hosted web server acting as the central hub, Google Sheets as the database, and integration points to Gmail (for input/output) and Slack (for notifications). This modular approach ensures each piece (email ingestion, form ingestion, data storage, approval processing, notifications) is decoupled and can be modified or extended independently.

Tech Stack Recommendations

Building on a platform like Replit, the following tech stack is recommended for rapid development and compatibility:
	•	Programming Language & Framework: Use a high-level language suited for web development and Google API integration. Two strong options are:
	•	Node.js with Express – Node has an official Google APIs client library (googleapis npm package) which covers Gmail and Sheets, and it handles asynchronous operations (useful for polling and API calls). Express is lightweight for building REST endpoints and serving pages. Many Slack integration examples use Node as well, making it easier to implement the webhook call.
	•	Python with Flask (or FastAPI) – Python’s google-api-python-client can interact with Google services, and Flask is simple for web endpoints. Python has easy-to-use libraries for parsing email content (if needed) and can also send HTTP requests (for Slack) with libraries like requests. FastAPI could be used for a more structured API approach, though Flask might suffice for MVP.
	•	Recommendation: If the development team is comfortable with JavaScript/TypeScript, Node/Express is a good choice for its event-driven nature and wide usage on Replit. If the team prefers Python, Flask is equally viable. Replit supports both well. The choice may come down to familiarity.
	•	Google APIs and SDKs:
	•	Utilize the Google Workspace APIs for Gmail and Sheets. For Node, the @googleapis library can manage auth and requests. For Python, google-api-python-client or the newer google.auth libraries work. These APIs will allow reading emails and managing spreadsheet data via secure HTTP calls ￼ ￼.
	•	Authentication to Google APIs can be handled via OAuth2 credentials. Because this is a server-side application, we can use a service account or a single Google account’s OAuth tokens:
	•	A Service Account (with domain-wide delegation if needed) could be created to access the Gmail mailbox and Sheets. This is more complex to set up (especially for Gmail, as it typically requires Workspace domain and impersonation). Alternatively,
	•	Use OAuth2 for a regular account: For example, register the app in Google Cloud Console, and perform a one-time OAuth consent flow to grant access to the Gmail account and the spreadsheet. Store the refresh token securely to allow the server continuous access. This might be easier if using one central account (like an “expenses bot” Google account).
	•	On Replit, environment variables should store sensitive OAuth credentials (client ID/secret, refresh token) and the Slack webhook URL.
	•	Web Framework & UI: As noted, Express (Node) or Flask (Python) will handle routing and server logic. For the UI:
	•	Use simple HTML/CSS/JS. You can use a CSS framework like Bootstrap to quickly style the interface to be clean and responsive (so approvers can even use it on a mobile browser if needed).
	•	Templating engines (like EJS/Pug for Node, Jinja2 for Python) help in generating dynamic pages (e.g., looping through expenses to create a table).
	•	Minimal front-end scripting: perhaps use vanilla JS or a library like jQuery for handling form submissions or button clicks (like an AJAX call to approve without reload). Since the user base is small, we don’t need a heavy SPA framework; keeping it simple will ease maintenance.
	•	Slack Integration: No special library is strictly needed – sending a Slack webhook can be done with an HTTP POST. In Node, use axios or the built-in https module; in Python, use requests. Slack’s own SDK (Bolt) is more for building interactive bots; here a webhook is enough. (If future requires interactive approvals via Slack, one might consider Slack bot APIs, but not for MVP.)
	•	Data Handling: For parsing email content, if we choose to implement it:
	•	In Node, one might use the imap or node-gmail-api packages, or just the Gmail REST API via googleapis. To parse email bodies, you might use simple string processing or regex, or parse MIME parts if needed (Node has libraries for parsing raw emails if we retrieve raw messages).
	•	In Python, the email standard library can parse raw email messages if using IMAP/POP. But using Gmail API, we get structured data (the message payload) which can be traversed for subject, body text, attachments encoded in base64, etc.
	•	Attachments could be handled by saving them to a temporary directory or directly uploading to Google Drive via its API (which might be a nice addition – storing all receipts in a Drive folder and keeping the Drive link in the Sheet). The Google Drive API could be part of the tech stack for this purpose, though not strictly required if we keep attachments in Gmail only. As a simpler approach, the app could forward the email or attachment to a fixed Google Drive folder via an integration.
	•	Running on Replit: Replit provides an easy way to host the web app. Some considerations:
	•	Use the Always-On feature (if available) to keep the server running so it can poll emails and respond to requests anytime. If Always-On is not enabled, consider using a workaround (like uptimerobot ping) to prevent sleep.
	•	Replit has a limit on long-running processes for free tier, but small scale usage should be fine. The tech stack should be lightweight (Express/Flask are fine).
	•	During development, Replit’s collaborative editor and its own AI development assistant can be used to expedite coding (the specification format here is intended to be easily parsed by such an AI assistant).
	•	Environment Variables: Replit’s Secrets manager will store things like GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, OAUTH_REFRESH_TOKEN, SLACK_WEBHOOK_URL, etc. The code should read these from environment on startup.
	•	Version Control & Deployment: Using Replit, each run in the IDE can serve as the deployment. It might be useful to connect a GitHub repository for version control of the code. The stack itself doesn’t require containerization beyond what Replit provides out of the box.

In summary, Node/Express with Google’s Node SDK and Slack webhooks, or Python/Flask with Google’s Python client, are the top choices. Both stacks integrate well on Replit. The decision should be based on team expertise. The rest of the tech (HTML/CSS UI, Google/Slack APIs, storing config in env) remains consistent across either choice.

API and Third-Party Integration Notes

Integrating with external APIs is a core part of this project. Below are key integration considerations for each third-party service/API:
	•	Gmail API (Google Mail): Used to retrieve expense submission emails and to send notification emails.
	•	Reading Emails: The Gmail API allows authorized apps to list and fetch messages from a mailbox ￼. We will use it to connect to the dedicated expenses inbox. For efficiency, use query parameters to search for relevant emails – e.g., label:inbox and maybe a specific subject prefix or sender. We might also create a Gmail filter to automatically label incoming expense emails, then the app can fetch only emails with that label (to ignore other non-expense emails if the inbox is shared).
	•	Parsing Emails: Once fetched, the email’s content (subject, body, attachments) will be processed. The Gmail API can return the email body in raw text or HTML. We should decide on a format for employees to submit data if we want easy parsing. For instance, the user could include a line like “Amount: $X, Date: YYYY-MM-DD, Category: Z” in the email – the app can use regex to extract those values. Attachments (receipt images) come base64-encoded via the API; we can save them to a file or upload to Drive.
	•	Sending Emails: The Gmail API also allows sending messages. We can utilize this to send approval/rejection notifications from the same or another Gmail account. This requires an additional scope (gmail.send). Alternatively, for simplicity, we could use a transactional email service or SMTP, but since we already have Google auth, Gmail API is convenient for sending as well. (Email content can be simple text, or we can use HTML for a nicer format.)
	•	Auth & Security: Gmail API scopes are sensitive (especially read access to emails). We must comply with Google’s OAuth consent requirements. Since this is an internal tool, we might keep the app in “Testing” mode or use a limited scope (e.g., gmail.readonly and gmail.send for only the needed Gmail). No user data beyond receipts is handled, but caution that if deploying beyond our domain, Google may require a security assessment. Keeping it internal avoids that. Note: According to Google’s guidelines, the Gmail API is the preferred method for authorized mailbox access in web apps ￼, rather than less secure IMAP with stored credentials.
	•	Error Handling: Implement retries or backoff if the Gmail API quota is exceeded. Also handle cases where an email is malformed or an attachment is too large (we might set a size limit for attachments, e.g., < 10MB, to match typical email limits).
	•	Google Sheets API: Used as the interface to our expense spreadsheet database.
	•	The Google Sheets API v4 enables reading and writing spreadsheet data via REST calls ￼. We will use it to append new rows (for new submissions), read rows (to display in UI), and update rows (on approval).
	•	Data Model: Define a fixed range or detect the first empty row. For example, maintain a header row with column names. When adding a row, we provide values in the order of columns. We should also decide how to identify a specific expense row for updates – options:
	•	Use the spreadsheet row number as an implicit ID (not ideal if sorting changes or if we ever delete rows).
	•	Or have an explicit “Expense ID” column (e.g., an auto-increment or a unique code). We can generate a simple ID (like a sequence or use the Google Form’s timestamp combined with user initials). This ID would be included in notifications and used to match records.
	•	Access: The app will need edit access to the Google Sheet. If using a service account, the sheet must be shared with that account’s email. If using OAuth for a user, that user must have access (owning the sheet or at least editor rights). For a Google Form-linked sheet, typically the form owner is the sheet owner, so ensure the integration account can access it as well.
	•	Schema Updates: If we update the sheet structure (add new columns like “Approved By” later), the API calls should be adjusted to include those fields. We should document the expected columns clearly in the code or config, so changes to the sheet don’t break the app.
	•	Rate limits: The Sheets API has generous quotas for read/write, but we should avoid overly frequent polling. Possibly batch reads (read a range of rows in one call) rather than per-row operations. For updating a single row’s cells, we can use the spreadsheets.values.update or batchUpdate if doing many at once.
	•	Alternative approaches: In some cases, Google Apps Script could be used to mediate between the form and sheet or handle approvals. However, since we’re building an external app, we stick to the direct Sheets API. We might use Apps Script in the future for advanced G Suite automation, but not required in this design.
	•	Google Forms: (If implemented for input)
	•	We do not necessarily need to use the Google Forms API for MVP. The form can simply submit to the Google Sheet. There is a Google Forms API (released recently) that allows reading responses via API, but since the responses are already in our sheet, we can just use the Sheets API to get them.
	•	One integration consideration: if we want to notify or trigger the app right when a form is submitted, we could add a Google Apps Script trigger on form submit, which makes an HTTP request to our web app (webhook style). This is a nice-to-have; otherwise, the app could poll the sheet for new entries occasionally.
	•	Make sure file upload questions on the form store files in a shared drive or a folder accessible to approvers. By default, form file uploads go to the form owner’s drive. We might put a link to that file in the sheet (which Forms does automatically – it places a Drive link in the responses sheet). Approvers will need permission to view those files; if they are in the same Google Workspace domain, that’s usually managed, but we must ensure the sharing settings allow it.
	•	Slack API (Incoming Webhooks): Used to send notifications to Slack channels/users about events.
	•	We will set up a Slack App in the company’s Slack workspace with the Incoming Webhook feature enabled. This gives a unique webhook URL (which we’ll keep secret) that the app can POST messages to ￼.
	•	Message Formatting: We can send a JSON payload with at least a "text" field for simple messages ￼. E.g., payload: {"text": "New expense submitted by *Jane Doe*: $45.00 - Office Supplies (click here to review)"}. We can enhance messages with Slack’s formatting or block kit in the future (e.g., “Approve” button in Slack), but MVP will keep it simple (text notifications).
	•	Channels: The webhook URL is tied to a specific channel (chosen when creating it). If we want to notify different managers individually, we might either create multiple webhooks or use Slack’s chat.postMessage API with a bot token to target users. MVP likely just posts all new submissions to a single finance channel, and perhaps approvals to that channel as well or to a general channel to celebrate closed reports.
	•	Reliability: If Slack posting fails (network issues or invalid webhook), the app should catch that error. It’s not critical to app functionality (it’s a convenience), so errors could be logged and maybe retried a bit, but not fatal. We might want to not block the main flow on Slack response – typically just fire-and-forget the POST (or handle asynchronously).
	•	Security: The webhook URL is essentially a secret token allowing access to post in our Slack. We must keep it in an environment variable, not in code. No inbound Slack data is taken, so surface area is minimal.
	•	Other Integrations (Future):
	•	Google Drive API: Consider using this to store receipt files (if we want a central repository of receipts). In MVP, this might be overkill, but if implementing, we’d have the app upload attachments to a specific Drive folder. The Sheets could then store the Drive file ID or link. Drive API integration would require an additional OAuth scope.
	•	OCR Service: If down the line we want to automatically extract text from receipt images (to avoid manual entry), we might integrate Google Vision API or a third-party OCR. That would be a separate API integration, sending image data and receiving parsed text. This is beyond MVP but noted for completeness.
	•	Messaging/Chat: If the agency uses other tools (Microsoft Teams, etc.), similar webhook integrations could be added later. The architecture is open to adding more notification endpoints (since we can abstract the notification sending logic to multiple channels).
	•	Accounting Systems: Future integration with QuickBooks, Xero, or similar could be done via their APIs to automatically send approved expenses into accounting. Not in scope now, but good to keep in mind that each expense has enough info (date, amount, category) to feed into such systems.

All API usage will require careful handling of credentials and respecting usage limits. We will use official SDKs where possible to simplify implementation and ensure best practices are followed (like exponential backoff on Google API calls, etc.). The integration choices above prioritize simplicity and reliability for a small-scale internal tool.

MVP Feature Set

The Minimum Viable Product will include a focused set of features that cover the essential needs:
	•	Single-Source Submission (Choose One Path): The MVP will implement one primary submission method initially to reduce complexity – likely the Google Form submission to Google Sheets path, because it provides structured data out-of-the-box. Employees will use the form to submit expenses (with file upload for receipts), and these entries populate the spreadsheet. (The email submission feature can be added in a later iteration unless it’s a high priority from day one. If email must be in MVP, we can start by handling a very basic parse of emails with a predefined format.) For MVP, assume the Google Form is the main input for reliability.
	•	Google Sheets Data Store (Configured): Set up the Google Sheets workbook with necessary columns:
	•	Form response columns: e.g., Timestamp, Employee Email, Expense Date, Amount, Category/Reason, Department, Receipt File Link.
	•	Added columns: Approval Status, Approval Notes, Approver Email, Decision Date, Email Sent (Y/N).
	•	The sheet is linked properly to the form (if form is used) and shared with the app’s service account or integration user. Data validation (dropdown for status) is set up on the sheet for ease of manual use too ￼.
	•	Sample data is entered to test the integration.
	•	Web Interface for Approvers: A protected web page where approvers can:
	•	View pending expenses: Display a list or table of all expenses with status “Pending”. Show key info like who submitted (email or name), date, amount, and reason. The receipt link should be accessible (e.g., a hyperlink to the image or file).
	•	Approve/Reject action: For each pending expense, provide buttons or an action form. Approver can select “Approve” or “Reject” and input a short note if rejecting (or even if approving, note can be optional).
	•	Update status: On action, the system updates the Google Sheet row (sets status to Approved/Rejected, writes the note and approver name/date). The entry then disappears from the pending list (or the page refreshes).
	•	A confirmation message is shown after an action (or the updated status is reflected immediately if using AJAX).
	•	Basic auth: The page is login-protected so only authorized users can access it (for MVP, a simple hardcoded username/password or a shared secret could be used, given it’s internal and low-risk; if time permits, implementing Google OAuth login would be great even in MVP to avoid credentials in code).
	•	Notifications on Approval Decision: Once an expense is processed (approved or rejected), the system sends an email notification to the submitter. This email includes the decision and any note (for rejection). For MVP, we will implement email notifications (since every submitter has an email). Slack notification to the submitter could also be considered if Slack usernames/emails can be mapped, but email is straightforward. The content will be templated (could be as simple as text: “Hi X, your expense submitted on 2025-06-01 for $123 has been Approved. Notes: …”). The “Email Sent” flag in the sheet is updated to “Y” to record that the notification was sent ￼ ￼.
	•	MVP Note: We may skip notifying approvers of new submissions in the very first version if we assume approvers will regularly check the tool. However, this is a small addition – sending a Slack message or email when a new form entry is added is useful. If time allows, we’ll include at least a Slack channel notification for new submissions in MVP, as this is easy once the webhook is set up.
	•	Basic Email/Form Parser: If the MVP includes the email submission route (assuming we do include it):
	•	Implement a background job (perhaps invoked on a schedule or manually via a button) that connects to Gmail, reads the latest unprocessed expense email, and tries to parse it.
	•	Use a simple heuristic or format: e.g., employees must include a line with “Amount:”, “Date:” etc. Parse those values, and record a new sheet entry. Save the email ID in a “Processed” label so we don’t double process.
	•	This parser doesn’t handle arbitrary receipts (no OCR), so it’s a limited feature. But it demonstrates the pipeline. Any email that can’t be parsed will be left in inbox for manual handling.
	•	Slack Webhook Integration: Set up Slack notifications (if included in MVP):
	•	When a new expense is submitted (new sheet row), post a message to Slack #expenses like “New expense submitted by John (Marketing): $200 – awaiting approval.”
	•	When an expense is approved or rejected, post a message like “Expense #123 (John, $200) Approved by Jane.”
	•	These messages help keep a record in Slack and prompt approvers. If the team prefers, this can be an email to a group instead of Slack, but Slack is real-time and less intrusive than email for each item.
	•	Testing & Verification in MVP: Ensure the following are tested:
	•	Submitting the Google Form creates a new row in Sheets, and that appears on the approver UI.
	•	Approver marking approve/reject updates the sheet and triggers the notification email to the submitter.
	•	The submitter receives the email and the sheet’s “Email Sent” is marked.
	•	Slack messages appear as expected when actions happen (if included).
	•	Security: verify that the approver page is not accessible without login (try incognito etc.).
	•	Performance: with a handful of entries, pages load quickly and API calls succeed within a second or two.
	•	Error conditions: try an invalid email format (if using email submission) to see how it’s handled, etc.

By focusing on the above core features, the MVP will deliver a working end-to-end expense tracking and approval system. It covers submission, storage, approval, and notification – which are the primary workflow steps needed to replace a tool like Expensify for basic use cases (minus the reimbursement processing). Users will be able to submit expenses and get decisions, and managers will have a central place to manage approvals.

Roadmap for Expansion

With the MVP in place, future iterations can expand the tool’s capabilities and robustness. The following are potential enhancements and next steps after the initial version:
	•	Enable Both Submission Channels: If the MVP started with only Google Form or only email, the next step is to support both modes fully. This means hardening the email parsing:
	•	Implement more sophisticated parsing of emailed receipts. This could involve recognizing common receipt email formats (for example, if an Uber receipt or Amazon receipt is forwarded, parse vendor name, date, amount from the email body). We might incorporate regex patterns for known vendors or even integrate an OCR service for image/PDF attachments to auto-extract text.
	•	For reliability, we might use an intermediate approach: use an expense submission template (e.g., a structured CSV or a specific email form) for employees who prefer email, to ensure parsing is accurate.
	•	Additionally, allow the web interface itself for direct submission as a third option. For example, an authenticated employee could fill out a small form on the web tool to submit an expense (this would just write to the sheet as well). This might be convenient for those who have access to the tool and want to bypass email/form.
	•	Multi-Level Approval Workflow: Introduce support for expenses that require multiple approvals:
	•	For instance, if an expense amount is above a certain threshold (e.g., > $1000), it could require a second-level approval (perhaps by a director or finance head). We would add a “Stage 2 Approval Status” column or a more complex state machine for approvals.
	•	Notifications would then go out to the second approver after the first approves, etc. This adds complexity in UI (showing if something is fully approved or pending secondary approval) but is useful as the organization grows or for compliance.
	•	Alternatively, allow each department’s manager to approve, then auto-notify finance for a final check. The roadmap can define these rules configurable (e.g., via a config file or sheet of approval rules).
	•	Improved Authentication & User Management:
	•	Implement Google OAuth SSO properly so that employees can log into the web app with their work Google accounts. This way, we can show each user only their own expenses (if we build a view for that) and ensure only authorized approvers have access to the admin functions. We can maintain a list of approver emails (perhaps in a config file or in the Google Sheet’s separate tab) and the app can check if current_user_email in approvers_list to grant access to approval features.
	•	Manage user roles (submitter vs approver vs admin) with more finesse. Possibly integrate with the company’s Google Workspace group (if the domain has a Google Group for managers, etc., though that might require Google Directory API).
	•	Add password reset or 2FA if we ever move away from Google OAuth for any reason.
	•	UI Enhancements and UX:
	•	Create a more comprehensive dashboard. For example, show summary statistics (total expenses submitted this month, how many approved, etc.), maybe a chart of expenses by category if the data is there.
	•	Provide filters and search on the expenses list (e.g., filter by employee, by date range, by status). This is useful as the number of records grows.
	•	Make the interface mobile-friendly (if not already) so that approvers can approve on the go easily.
	•	Possibly implement an email approval feature: e.g., an approver could reply to the notification email with “Approve” or click an approval link in the email, which would automatically update the status without needing to log into the UI (this could be done by processing email replies or by generating a secure one-time link in the email that the approver can click to approve).
	•	Slack/Bot Interaction: Enhance Slack integration to allow two-way interaction:
	•	For instance, use Slack buttons or slash commands to let managers approve expenses directly from Slack. Slack messages could have “Approve/Reject” buttons (using Slack Block Kit and an interactive endpoint). Our app would then need to handle Slack interaction events (which requires a Slack app with permissions and a public endpoint). This could streamline the process by letting approvers stay within Slack.
	•	Alternatively, implement Slack DM notifications to the specific manager responsible for an expense (if the system knows department managers and can map submitter to their manager). This personalizes notifications instead of a channel.
	•	Integration with Reimbursement/Accounting Systems:
	•	Once an expense is approved, we could automatically push the data to an external system for payment. For example, integrate with an accounting software’s API (QuickBooks, Oracle Netsuite, etc.) to create an expense entry or a payable. Or integrate with the payroll system to mark that amount to be reimbursed in the next paycheck.
	•	This would close the loop, though it requires significant understanding of external systems. For a small agency, possibly generating a simple report of approved expenses monthly might be enough (which finance then uses to manually reimburse). We could automate that report: e.g., a “Export to CSV/PDF” of all approved expenses for a given period.
	•	Reporting and Analytics:
	•	Add pages or functionality for expense reports and analytics. E.g., a page where an admin can select a date range and see all expenses in that period, total sums by category or by employee, etc. This could be done by querying the Google Sheet or importing the data into a small database if needed for complex queries.
	•	Visualizations (maybe leveraging Google Charts or any chart library) for things like “Expenses by Category pie chart” or “Expenses by Month line chart” for management overview.
	•	Perhaps incorporate budgets: allow setting a monthly or project budget and track against it.
	•	Scalability and Data Management:
	•	If the agency grows, Google Sheets might become a bottleneck (it has a limit of ~5 million cells, and heavy concurrent access can be slow). A roadmap item could be migrating the backend database to a proper database (e.g., a cloud SQL or a lightweight SQLite on Replit if concurrency is low). The app could then use an ORM and keep Sheets mainly as an import/export method or drop Sheets entirely. This would be a larger change, so likely only if needed.
	•	In the interim, we could also implement archiving old entries (e.g., move last year’s expenses to a different sheet or CSV) to keep the main sheet lean.
	•	Audit Trail and Compliance:
	•	Enhance logging. For instance, log every action (submission, approval, rejection) in a separate log file or sheet tab. Include timestamps and user IDs. This helps with audits.
	•	Possibly add a feature for users to digitally sign their submissions or for approvers to sign (could be as simple as capturing their Google account as identity, or as fancy as integrating DocuSign for approvals – likely overkill).
	•	Ensure the tool complies with any company policies or legal requirements (for example, if receipts need to be retained for X years, make sure our storage meets that).
	•	Quality of Life Improvements:
	•	Email Reminders: If an expense sits pending for too long, the system could send reminders to the approver or escalate to another person after a certain SLA. This would require tracking submission time vs current time.
	•	Multiple Currencies or Categories: If the agency deals with different currencies, allow currency field and possibly integrate a conversion API for reporting in a base currency. Also, allow more granular categories or projects to be attached to expenses (which could then integrate with project tracking systems).
	•	UI for Sheet Management: A settings page in the app where an admin can update configuration like Slack webhook URL, list of approvers, thresholds for approvals, etc., without editing the code. This could simply read from a config file or a “Settings” sheet. It makes the system more flexible as requirements evolve.
	•	Testing and CI/CD: As the project grows, introduce more automated testing (unit tests for the parsing logic, integration tests using a test Google Sheet, etc.). And possibly a deployment pipeline if moving off Replit to a more robust host. But for now, Replit suffices.

Each of these roadmap items can be tackled incrementally. The immediate next steps after MVP would likely be enabling the second submission method (to cover both email and form users) and improving the authentication/security with Google OAuth, as those give immediate value. Subsequent iterations would focus on convenience features (Slack approvals, etc.) and integrations that reduce manual work (accounting sync). By following this roadmap, the internal tool can steadily evolve from a simple tracker into a more powerful expense management system tailored to the agency’s needs, all while avoiding unnecessary complexity for a small team.